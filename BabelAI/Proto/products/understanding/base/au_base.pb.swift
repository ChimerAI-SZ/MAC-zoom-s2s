// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: products/understanding/base/au_base.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 ByteDance Inc. All rights reserved.
// Author: Yu WenTeng (yuwenteng@bytedance.com)

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Data_Speech_Understanding_Code: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case errorUnspecified // = 0
  case success // = 21000

  /// request related
  case invalidRequest // = 11100
  case permissionDenied // = 11200
  case limitQps // = 11301
  case limitCount // = 11302
  case serverBusy // = 11303
  case interrupted // = 21300
  case errorParams // = 11500

  /// audio related
  case longAudio // = 11101
  case largePacket // = 11102
  case invalidFormat // = 11103
  case silentAudio // = 11104
  case emptyAudio // = 11105
  case audioDownloadFail // = 21701

  /// recognition related
  case timeoutWaiting // = 21200
  case timeoutProcessing // = 21201
  case errorProcessing // = 21100

  /// others
  case errorUnknown // = 29900
  case UNRECOGNIZED(Int)

  init() {
    self = .errorUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .errorUnspecified
    case 11100: self = .invalidRequest
    case 11101: self = .longAudio
    case 11102: self = .largePacket
    case 11103: self = .invalidFormat
    case 11104: self = .silentAudio
    case 11105: self = .emptyAudio
    case 11200: self = .permissionDenied
    case 11301: self = .limitQps
    case 11302: self = .limitCount
    case 11303: self = .serverBusy
    case 11500: self = .errorParams
    case 21000: self = .success
    case 21100: self = .errorProcessing
    case 21200: self = .timeoutWaiting
    case 21201: self = .timeoutProcessing
    case 21300: self = .interrupted
    case 21701: self = .audioDownloadFail
    case 29900: self = .errorUnknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .errorUnspecified: return 0
    case .invalidRequest: return 11100
    case .longAudio: return 11101
    case .largePacket: return 11102
    case .invalidFormat: return 11103
    case .silentAudio: return 11104
    case .emptyAudio: return 11105
    case .permissionDenied: return 11200
    case .limitQps: return 11301
    case .limitCount: return 11302
    case .serverBusy: return 11303
    case .errorParams: return 11500
    case .success: return 21000
    case .errorProcessing: return 21100
    case .timeoutWaiting: return 21200
    case .timeoutProcessing: return 21201
    case .interrupted: return 21300
    case .audioDownloadFail: return 21701
    case .errorUnknown: return 29900
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Data_Speech_Understanding_Code] = [
    .errorUnspecified,
    .success,
    .invalidRequest,
    .permissionDenied,
    .limitQps,
    .limitCount,
    .serverBusy,
    .interrupted,
    .errorParams,
    .longAudio,
    .largePacket,
    .invalidFormat,
    .silentAudio,
    .emptyAudio,
    .audioDownloadFail,
    .timeoutWaiting,
    .timeoutProcessing,
    .errorProcessing,
    .errorUnknown,
  ]

}

enum Data_Speech_Understanding_AsrNotificationCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case notificationUnspecified // = 0
  case disconnect // = 1000
  case UNRECOGNIZED(Int)

  init() {
    self = .notificationUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notificationUnspecified
    case 1000: self = .disconnect
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notificationUnspecified: return 0
    case .disconnect: return 1000
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Data_Speech_Understanding_AsrNotificationCode] = [
    .notificationUnspecified,
    .disconnect,
  ]

}

struct Data_Speech_Understanding_Word: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var startTime: Int32 = 0

  var endTime: Int32 = 0

  var blankDuration: Int32 = 0

  var pronounce: String = String()

  var confidence: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_UtteranceAddition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_ResultAddition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_Utterance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var startTime: Int32 = 0

  var endTime: Int32 = 0

  var definite: Bool {
    get {return _definite ?? false}
    set {_definite = newValue}
  }
  /// Returns true if `definite` has been explicitly set.
  var hasDefinite: Bool {return self._definite != nil}
  /// Clears the value of `definite`. Subsequent reads from it will return its default value.
  mutating func clearDefinite() {self._definite = nil}

  var words: [Data_Speech_Understanding_Word] = []

  var language: String = String()

  var confidence: Double = 0

  var speaker: Int32 = 0

  var channelID: Int32 = 0

  var additions: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _definite: Bool? = nil
}

struct Data_Speech_Understanding_LanguageDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// language probability
  var prob: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var utterances: [Data_Speech_Understanding_Utterance] = []

  var confidence: Double = 0

  var globalConfidence: Double = 0

  var language: String = String()

  var languageDetails: Dictionary<String,Data_Speech_Understanding_LanguageDetail> = [:]

  var termination: Bool {
    get {return _termination ?? false}
    set {_termination = newValue}
  }
  /// Returns true if `termination` has been explicitly set.
  var hasTermination: Bool {return self._termination != nil}
  /// Clears the value of `termination`. Subsequent reads from it will return its default value.
  mutating func clearTermination() {self._termination = nil}

  var volume: Double = 0

  var speechRate: Double = 0

  var resultType: String = String()

  var oriText: String = String()

  var prefetch: Bool {
    get {return _prefetch ?? false}
    set {_prefetch = newValue}
  }
  /// Returns true if `prefetch` has been explicitly set.
  var hasPrefetch: Bool {return self._prefetch != nil}
  /// Clears the value of `prefetch`. Subsequent reads from it will return its default value.
  mutating func clearPrefetch() {self._prefetch = nil}

  var additions: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _termination: Bool? = nil
  fileprivate var _prefetch: Bool? = nil
}

struct Data_Speech_Understanding_AudioInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var duration: Int64 = 0

  var speechRate: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_App: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var workFlowName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_User: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uid: String = String()

  var did: String = String()

  /// android or ios info
  var platform: String = String()

  var sdkVersion: String = String()

  var appVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_Audio: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: String = String()

  var url: String = String()

  /// url; vid...
  var urlType: String = String()

  var format: String = String()

  var codec: String = String()

  var language: String = String()

  var rate: Int32 = 0

  var bits: Int32 = 0

  var channel: Int32 = 0

  var tosBucket: String = String()

  var tosAccessKey: String = String()

  var audioTosObject: String = String()

  var roleTrn: String = String()

  var binaryData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_AsrNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Data_Speech_Understanding_AsrNotificationCode = .notificationUnspecified

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Understanding_ReqParams: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用于映射集群
  var modelName: String {
    get {return _storage._modelName}
    set {_uniqueStorage()._modelName = newValue}
  }

  /// 用于映射tcc配置
  var configName: String {
    get {return _storage._configName}
    set {_uniqueStorage()._configName = newValue}
  }

  var enableVad: Bool {
    get {return _storage._enableVad ?? false}
    set {_uniqueStorage()._enableVad = newValue}
  }
  /// Returns true if `enableVad` has been explicitly set.
  var hasEnableVad: Bool {return _storage._enableVad != nil}
  /// Clears the value of `enableVad`. Subsequent reads from it will return its default value.
  mutating func clearEnableVad() {_uniqueStorage()._enableVad = nil}

  var enablePunc: Bool {
    get {return _storage._enablePunc ?? false}
    set {_uniqueStorage()._enablePunc = newValue}
  }
  /// Returns true if `enablePunc` has been explicitly set.
  var hasEnablePunc: Bool {return _storage._enablePunc != nil}
  /// Clears the value of `enablePunc`. Subsequent reads from it will return its default value.
  mutating func clearEnablePunc() {_uniqueStorage()._enablePunc = nil}

  var enableItn: Bool {
    get {return _storage._enableItn ?? false}
    set {_uniqueStorage()._enableItn = newValue}
  }
  /// Returns true if `enableItn` has been explicitly set.
  var hasEnableItn: Bool {return _storage._enableItn != nil}
  /// Clears the value of `enableItn`. Subsequent reads from it will return its default value.
  mutating func clearEnableItn() {_uniqueStorage()._enableItn = nil}

  var enableDdc: Bool {
    get {return _storage._enableDdc ?? false}
    set {_uniqueStorage()._enableDdc = newValue}
  }
  /// Returns true if `enableDdc` has been explicitly set.
  var hasEnableDdc: Bool {return _storage._enableDdc != nil}
  /// Clears the value of `enableDdc`. Subsequent reads from it will return its default value.
  mutating func clearEnableDdc() {_uniqueStorage()._enableDdc = nil}

  var enableResample: Bool {
    get {return _storage._enableResample ?? false}
    set {_uniqueStorage()._enableResample = newValue}
  }
  /// Returns true if `enableResample` has been explicitly set.
  var hasEnableResample: Bool {return _storage._enableResample != nil}
  /// Clears the value of `enableResample`. Subsequent reads from it will return its default value.
  mutating func clearEnableResample() {_uniqueStorage()._enableResample = nil}

  var vadSignal: Bool {
    get {return _storage._vadSignal ?? false}
    set {_uniqueStorage()._vadSignal = newValue}
  }
  /// Returns true if `vadSignal` has been explicitly set.
  var hasVadSignal: Bool {return _storage._vadSignal != nil}
  /// Clears the value of `vadSignal`. Subsequent reads from it will return its default value.
  mutating func clearVadSignal() {_uniqueStorage()._vadSignal = nil}

  var enableTranslate: Bool {
    get {return _storage._enableTranslate ?? false}
    set {_uniqueStorage()._enableTranslate = newValue}
  }
  /// Returns true if `enableTranslate` has been explicitly set.
  var hasEnableTranslate: Bool {return _storage._enableTranslate != nil}
  /// Clears the value of `enableTranslate`. Subsequent reads from it will return its default value.
  mutating func clearEnableTranslate() {_uniqueStorage()._enableTranslate = nil}

  var disableEndPunc: Bool {
    get {return _storage._disableEndPunc ?? false}
    set {_uniqueStorage()._disableEndPunc = newValue}
  }
  /// Returns true if `disableEndPunc` has been explicitly set.
  var hasDisableEndPunc: Bool {return _storage._disableEndPunc != nil}
  /// Clears the value of `disableEndPunc`. Subsequent reads from it will return its default value.
  mutating func clearDisableEndPunc() {_uniqueStorage()._disableEndPunc = nil}

  var enableSpeakerInfo: Bool {
    get {return _storage._enableSpeakerInfo ?? false}
    set {_uniqueStorage()._enableSpeakerInfo = newValue}
  }
  /// Returns true if `enableSpeakerInfo` has been explicitly set.
  var hasEnableSpeakerInfo: Bool {return _storage._enableSpeakerInfo != nil}
  /// Clears the value of `enableSpeakerInfo`. Subsequent reads from it will return its default value.
  mutating func clearEnableSpeakerInfo() {_uniqueStorage()._enableSpeakerInfo = nil}

  var enableChannelSplit: Bool {
    get {return _storage._enableChannelSplit ?? false}
    set {_uniqueStorage()._enableChannelSplit = newValue}
  }
  /// Returns true if `enableChannelSplit` has been explicitly set.
  var hasEnableChannelSplit: Bool {return _storage._enableChannelSplit != nil}
  /// Clears the value of `enableChannelSplit`. Subsequent reads from it will return its default value.
  mutating func clearEnableChannelSplit() {_uniqueStorage()._enableChannelSplit = nil}

  var appLang: String {
    get {return _storage._appLang}
    set {_uniqueStorage()._appLang = newValue}
  }

  var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  var audioType: String {
    get {return _storage._audioType}
    set {_uniqueStorage()._audioType = newValue}
  }

  var enableLid: Bool {
    get {return _storage._enableLid ?? false}
    set {_uniqueStorage()._enableLid = newValue}
  }
  /// Returns true if `enableLid` has been explicitly set.
  var hasEnableLid: Bool {return _storage._enableLid != nil}
  /// Clears the value of `enableLid`. Subsequent reads from it will return its default value.
  mutating func clearEnableLid() {_uniqueStorage()._enableLid = nil}

  var reco2ActNumSpk: Int32 {
    get {return _storage._reco2ActNumSpk}
    set {_uniqueStorage()._reco2ActNumSpk = newValue}
  }

  var reco2MaxNumSpk: Int32 {
    get {return _storage._reco2MaxNumSpk}
    set {_uniqueStorage()._reco2MaxNumSpk = newValue}
  }

  var enableInterrupt: Bool {
    get {return _storage._enableInterrupt ?? false}
    set {_uniqueStorage()._enableInterrupt = newValue}
  }
  /// Returns true if `enableInterrupt` has been explicitly set.
  var hasEnableInterrupt: Bool {return _storage._enableInterrupt != nil}
  /// Clears the value of `enableInterrupt`. Subsequent reads from it will return its default value.
  mutating func clearEnableInterrupt() {_uniqueStorage()._enableInterrupt = nil}

  var vadSegment: Bool {
    get {return _storage._vadSegment ?? false}
    set {_uniqueStorage()._vadSegment = newValue}
  }
  /// Returns true if `vadSegment` has been explicitly set.
  var hasVadSegment: Bool {return _storage._vadSegment != nil}
  /// Clears the value of `vadSegment`. Subsequent reads from it will return its default value.
  mutating func clearVadSegment() {_uniqueStorage()._vadSegment = nil}

  var enableOriText: Bool {
    get {return _storage._enableOriText ?? false}
    set {_uniqueStorage()._enableOriText = newValue}
  }
  /// Returns true if `enableOriText` has been explicitly set.
  var hasEnableOriText: Bool {return _storage._enableOriText != nil}
  /// Clears the value of `enableOriText`. Subsequent reads from it will return its default value.
  mutating func clearEnableOriText() {_uniqueStorage()._enableOriText = nil}

  var enableNonstream: Bool {
    get {return _storage._enableNonstream ?? false}
    set {_uniqueStorage()._enableNonstream = newValue}
  }
  /// Returns true if `enableNonstream` has been explicitly set.
  var hasEnableNonstream: Bool {return _storage._enableNonstream != nil}
  /// Clears the value of `enableNonstream`. Subsequent reads from it will return its default value.
  mutating func clearEnableNonstream() {_uniqueStorage()._enableNonstream = nil}

  var showUtterances: Bool {
    get {return _storage._showUtterances ?? false}
    set {_uniqueStorage()._showUtterances = newValue}
  }
  /// Returns true if `showUtterances` has been explicitly set.
  var hasShowUtterances: Bool {return _storage._showUtterances != nil}
  /// Clears the value of `showUtterances`. Subsequent reads from it will return its default value.
  mutating func clearShowUtterances() {_uniqueStorage()._showUtterances = nil}

  var showWords: Bool {
    get {return _storage._showWords ?? false}
    set {_uniqueStorage()._showWords = newValue}
  }
  /// Returns true if `showWords` has been explicitly set.
  var hasShowWords: Bool {return _storage._showWords != nil}
  /// Clears the value of `showWords`. Subsequent reads from it will return its default value.
  mutating func clearShowWords() {_uniqueStorage()._showWords = nil}

  var showDuration: Bool {
    get {return _storage._showDuration ?? false}
    set {_uniqueStorage()._showDuration = newValue}
  }
  /// Returns true if `showDuration` has been explicitly set.
  var hasShowDuration: Bool {return _storage._showDuration != nil}
  /// Clears the value of `showDuration`. Subsequent reads from it will return its default value.
  mutating func clearShowDuration() {_uniqueStorage()._showDuration = nil}

  var showLanguage: Bool {
    get {return _storage._showLanguage ?? false}
    set {_uniqueStorage()._showLanguage = newValue}
  }
  /// Returns true if `showLanguage` has been explicitly set.
  var hasShowLanguage: Bool {return _storage._showLanguage != nil}
  /// Clears the value of `showLanguage`. Subsequent reads from it will return its default value.
  mutating func clearShowLanguage() {_uniqueStorage()._showLanguage = nil}

  var showVolume: Bool {
    get {return _storage._showVolume ?? false}
    set {_uniqueStorage()._showVolume = newValue}
  }
  /// Returns true if `showVolume` has been explicitly set.
  var hasShowVolume: Bool {return _storage._showVolume != nil}
  /// Clears the value of `showVolume`. Subsequent reads from it will return its default value.
  mutating func clearShowVolume() {_uniqueStorage()._showVolume = nil}

  var showVolumeV: Bool {
    get {return _storage._showVolumeV ?? false}
    set {_uniqueStorage()._showVolumeV = newValue}
  }
  /// Returns true if `showVolumeV` has been explicitly set.
  var hasShowVolumeV: Bool {return _storage._showVolumeV != nil}
  /// Clears the value of `showVolumeV`. Subsequent reads from it will return its default value.
  mutating func clearShowVolumeV() {_uniqueStorage()._showVolumeV = nil}

  var showSpeechRate: Bool {
    get {return _storage._showSpeechRate ?? false}
    set {_uniqueStorage()._showSpeechRate = newValue}
  }
  /// Returns true if `showSpeechRate` has been explicitly set.
  var hasShowSpeechRate: Bool {return _storage._showSpeechRate != nil}
  /// Clears the value of `showSpeechRate`. Subsequent reads from it will return its default value.
  mutating func clearShowSpeechRate() {_uniqueStorage()._showSpeechRate = nil}

  var showPrefetch: Bool {
    get {return _storage._showPrefetch ?? false}
    set {_uniqueStorage()._showPrefetch = newValue}
  }
  /// Returns true if `showPrefetch` has been explicitly set.
  var hasShowPrefetch: Bool {return _storage._showPrefetch != nil}
  /// Clears the value of `showPrefetch`. Subsequent reads from it will return its default value.
  mutating func clearShowPrefetch() {_uniqueStorage()._showPrefetch = nil}

  var resultType: String {
    get {return _storage._resultType}
    set {_uniqueStorage()._resultType = newValue}
  }

  var startSilenceTime: Int32 {
    get {return _storage._startSilenceTime}
    set {_uniqueStorage()._startSilenceTime = newValue}
  }

  var endSilenceTime: Int32 {
    get {return _storage._endSilenceTime}
    set {_uniqueStorage()._endSilenceTime = newValue}
  }

  var vadSilenceTime: Int32 {
    get {return _storage._vadSilenceTime}
    set {_uniqueStorage()._vadSilenceTime = newValue}
  }

  var minSilenceTime: Int32 {
    get {return _storage._minSilenceTime}
    set {_uniqueStorage()._minSilenceTime = newValue}
  }

  var vadMode: String {
    get {return _storage._vadMode}
    set {_uniqueStorage()._vadMode = newValue}
  }

  var vadSegmentDuration: Int32 {
    get {return _storage._vadSegmentDuration}
    set {_uniqueStorage()._vadSegmentDuration = newValue}
  }

  var endWindowSize: Int32 {
    get {return _storage._endWindowSize}
    set {_uniqueStorage()._endWindowSize = newValue}
  }

  var forceToSpeechTime: Int32 {
    get {return _storage._forceToSpeechTime}
    set {_uniqueStorage()._forceToSpeechTime = newValue}
  }

  var corpus: Data_Speech_Understanding_Corpus {
    get {return _storage._corpus ?? Data_Speech_Understanding_Corpus()}
    set {_uniqueStorage()._corpus = newValue}
  }
  /// Returns true if `corpus` has been explicitly set.
  var hasCorpus: Bool {return _storage._corpus != nil}
  /// Clears the value of `corpus`. Subsequent reads from it will return its default value.
  mutating func clearCorpus() {_uniqueStorage()._corpus = nil}

  var notification: Data_Speech_Understanding_AsrNotification {
    get {return _storage._notification ?? Data_Speech_Understanding_AsrNotification()}
    set {_uniqueStorage()._notification = newValue}
  }
  /// Returns true if `notification` has been explicitly set.
  var hasNotification: Bool {return _storage._notification != nil}
  /// Clears the value of `notification`. Subsequent reads from it will return its default value.
  mutating func clearNotification() {_uniqueStorage()._notification = nil}

  var sensitiveWordsFilter: String {
    get {return _storage._sensitiveWordsFilter}
    set {_uniqueStorage()._sensitiveWordsFilter = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Data_Speech_Understanding_Corpus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// json格式，包含热词，冷词，篇章，纠错词表等
  var context: String = String()

  var boostingTableID: String = String()

  var boostingTableName: String = String()

  var boostingID: String = String()

  var nnlmID: String = String()

  var correctTableID: String = String()

  var correctTableName: String = String()

  var puncHotWords: String = String()

  var hotWordsList: [String] = []

  var glossaryList: Dictionary<String,String> = [:]

  var showMatchHotWords: Bool {
    get {return _showMatchHotWords ?? false}
    set {_showMatchHotWords = newValue}
  }
  /// Returns true if `showMatchHotWords` has been explicitly set.
  var hasShowMatchHotWords: Bool {return self._showMatchHotWords != nil}
  /// Clears the value of `showMatchHotWords`. Subsequent reads from it will return its default value.
  mutating func clearShowMatchHotWords() {self._showMatchHotWords = nil}

  var showAllMatchHotWords: Bool {
    get {return _showAllMatchHotWords ?? false}
    set {_showAllMatchHotWords = newValue}
  }
  /// Returns true if `showAllMatchHotWords` has been explicitly set.
  var hasShowAllMatchHotWords: Bool {return self._showAllMatchHotWords != nil}
  /// Clears the value of `showAllMatchHotWords`. Subsequent reads from it will return its default value.
  mutating func clearShowAllMatchHotWords() {self._showAllMatchHotWords = nil}

  var showEffectiveHotWords: Bool {
    get {return _showEffectiveHotWords ?? false}
    set {_showEffectiveHotWords = newValue}
  }
  /// Returns true if `showEffectiveHotWords` has been explicitly set.
  var hasShowEffectiveHotWords: Bool {return self._showEffectiveHotWords != nil}
  /// Clears the value of `showEffectiveHotWords`. Subsequent reads from it will return its default value.
  mutating func clearShowEffectiveHotWords() {self._showEffectiveHotWords = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _showMatchHotWords: Bool? = nil
  fileprivate var _showAllMatchHotWords: Bool? = nil
  fileprivate var _showEffectiveHotWords: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "data.speech.understanding"

extension Data_Speech_Understanding_Code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ERROR_UNSPECIFIED\0\u{2}\\m\u{2}INVALID_REQUEST\0\u{1}LONG_AUDIO\0\u{1}LARGE_PACKET\0\u{1}INVALID_FORMAT\0\u{1}SILENT_AUDIO\0\u{1}EMPTY_AUDIO\0\u{2}_\u{1}PERMISSION_DENIED\0\u{2}e\u{1}LIMIT_QPS\0\u{1}LIMIT_COUNT\0\u{1}SERVER_BUSY\0\u{2}E\u{3}ERROR_PARAMS\0\u{2}\\T\u{2}SUCCESS\0\u{2}d\u{1}ERROR_PROCESSING\0\u{2}d\u{1}TIMEOUT_WAITING\0\u{1}TIMEOUT_PROCESSING\0\u{2}c\u{1}INTERRUPTED\0\u{2}Q\u{6}AUDIO_DOWNLOAD_FAIL\0\u{2}G@\u{2}ERROR_UNKNOWN\0")
}

extension Data_Speech_Understanding_AsrNotificationCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOTIFICATION_UNSPECIFIED\0\u{2}h\u{f}DISCONNECT\0")
}

extension Data_Speech_Understanding_Word: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Word"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}start_time\0\u{3}end_time\0\u{3}blank_duration\0\u{1}pronounce\0\u{1}confidence\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.blankDuration) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pronounce) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt32Field(value: self.startTime, fieldNumber: 2)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt32Field(value: self.endTime, fieldNumber: 3)
    }
    if self.blankDuration != 0 {
      try visitor.visitSingularInt32Field(value: self.blankDuration, fieldNumber: 4)
    }
    if !self.pronounce.isEmpty {
      try visitor.visitSingularStringField(value: self.pronounce, fieldNumber: 5)
    }
    if self.confidence.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_Word, rhs: Data_Speech_Understanding_Word) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.blankDuration != rhs.blankDuration {return false}
    if lhs.pronounce != rhs.pronounce {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_UtteranceAddition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtteranceAddition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_UtteranceAddition, rhs: Data_Speech_Understanding_UtteranceAddition) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_ResultAddition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResultAddition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_ResultAddition, rhs: Data_Speech_Understanding_ResultAddition) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_Utterance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Utterance"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}start_time\0\u{3}end_time\0\u{1}definite\0\u{1}words\0\u{1}language\0\u{1}confidence\0\u{1}speaker\0\u{3}channel_id\0\u{2}[\u{1}additions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endTime) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._definite) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.words) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.speaker) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.channelID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.additions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt32Field(value: self.startTime, fieldNumber: 2)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt32Field(value: self.endTime, fieldNumber: 3)
    }
    try { if let v = self._definite {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    if !self.words.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.words, fieldNumber: 5)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 6)
    }
    if self.confidence.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 7)
    }
    if self.speaker != 0 {
      try visitor.visitSingularInt32Field(value: self.speaker, fieldNumber: 8)
    }
    if self.channelID != 0 {
      try visitor.visitSingularInt32Field(value: self.channelID, fieldNumber: 9)
    }
    if !self.additions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.additions, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_Utterance, rhs: Data_Speech_Understanding_Utterance) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs._definite != rhs._definite {return false}
    if lhs.words != rhs.words {return false}
    if lhs.language != rhs.language {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.speaker != rhs.speaker {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.additions != rhs.additions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_LanguageDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LanguageDetail"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}prob\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.prob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.prob.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.prob, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_LanguageDetail, rhs: Data_Speech_Understanding_LanguageDetail) -> Bool {
    if lhs.prob != rhs.prob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Result"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{1}utterances\0\u{1}confidence\0\u{3}global_confidence\0\u{1}language\0\u{3}language_details\0\u{1}termination\0\u{1}volume\0\u{3}speech_rate\0\u{3}result_type\0\u{3}ori_text\0\u{1}prefetch\0\u{2}X\u{1}additions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.utterances) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.globalConfidence) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Data_Speech_Understanding_LanguageDetail>.self, value: &self.languageDetails) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._termination) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.volume) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.speechRate) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.resultType) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.oriText) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._prefetch) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.additions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.utterances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utterances, fieldNumber: 2)
    }
    if self.confidence.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 3)
    }
    if self.globalConfidence.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.globalConfidence, fieldNumber: 4)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 5)
    }
    if !self.languageDetails.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Data_Speech_Understanding_LanguageDetail>.self, value: self.languageDetails, fieldNumber: 6)
    }
    try { if let v = self._termination {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    if self.volume.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.volume, fieldNumber: 8)
    }
    if self.speechRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.speechRate, fieldNumber: 9)
    }
    if !self.resultType.isEmpty {
      try visitor.visitSingularStringField(value: self.resultType, fieldNumber: 10)
    }
    if !self.oriText.isEmpty {
      try visitor.visitSingularStringField(value: self.oriText, fieldNumber: 11)
    }
    try { if let v = self._prefetch {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    } }()
    if !self.additions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.additions, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_Result, rhs: Data_Speech_Understanding_Result) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.utterances != rhs.utterances {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.globalConfidence != rhs.globalConfidence {return false}
    if lhs.language != rhs.language {return false}
    if lhs.languageDetails != rhs.languageDetails {return false}
    if lhs._termination != rhs._termination {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.speechRate != rhs.speechRate {return false}
    if lhs.resultType != rhs.resultType {return false}
    if lhs.oriText != rhs.oriText {return false}
    if lhs._prefetch != rhs._prefetch {return false}
    if lhs.additions != rhs.additions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_AudioInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}duration\0\u{3}speech_rate\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.speechRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 1)
    }
    if self.speechRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.speechRate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_AudioInfo, rhs: Data_Speech_Understanding_AudioInfo) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.speechRate != rhs.speechRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_App: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".App"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}work_flow_name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workFlowName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workFlowName.isEmpty {
      try visitor.visitSingularStringField(value: self.workFlowName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_App, rhs: Data_Speech_Understanding_App) -> Bool {
    if lhs.workFlowName != rhs.workFlowName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uid\0\u{1}did\0\u{1}platform\0\u{3}sdk_version\0\u{3}app_version\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.did) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sdkVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 4)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_User, rhs: Data_Speech_Understanding_User) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.did != rhs.did {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Audio"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0\u{1}url\0\u{3}url_type\0\u{1}format\0\u{1}codec\0\u{1}language\0\u{1}rate\0\u{1}bits\0\u{1}channel\0\u{3}tos_bucket\0\u{3}tos_access_key\0\u{3}audio_tos_object\0\u{3}role_trn\0\u{3}binary_data\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.urlType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.codec) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.rate) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.bits) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.channel) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.tosBucket) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.tosAccessKey) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.audioTosObject) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.roleTrn) }()
      case 14: try { try decoder.decodeSingularBytesField(value: &self.binaryData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.urlType.isEmpty {
      try visitor.visitSingularStringField(value: self.urlType, fieldNumber: 3)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 4)
    }
    if !self.codec.isEmpty {
      try visitor.visitSingularStringField(value: self.codec, fieldNumber: 5)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 6)
    }
    if self.rate != 0 {
      try visitor.visitSingularInt32Field(value: self.rate, fieldNumber: 7)
    }
    if self.bits != 0 {
      try visitor.visitSingularInt32Field(value: self.bits, fieldNumber: 8)
    }
    if self.channel != 0 {
      try visitor.visitSingularInt32Field(value: self.channel, fieldNumber: 9)
    }
    if !self.tosBucket.isEmpty {
      try visitor.visitSingularStringField(value: self.tosBucket, fieldNumber: 10)
    }
    if !self.tosAccessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.tosAccessKey, fieldNumber: 11)
    }
    if !self.audioTosObject.isEmpty {
      try visitor.visitSingularStringField(value: self.audioTosObject, fieldNumber: 12)
    }
    if !self.roleTrn.isEmpty {
      try visitor.visitSingularStringField(value: self.roleTrn, fieldNumber: 13)
    }
    if !self.binaryData.isEmpty {
      try visitor.visitSingularBytesField(value: self.binaryData, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_Audio, rhs: Data_Speech_Understanding_Audio) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.url != rhs.url {return false}
    if lhs.urlType != rhs.urlType {return false}
    if lhs.format != rhs.format {return false}
    if lhs.codec != rhs.codec {return false}
    if lhs.language != rhs.language {return false}
    if lhs.rate != rhs.rate {return false}
    if lhs.bits != rhs.bits {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.tosBucket != rhs.tosBucket {return false}
    if lhs.tosAccessKey != rhs.tosAccessKey {return false}
    if lhs.audioTosObject != rhs.audioTosObject {return false}
    if lhs.roleTrn != rhs.roleTrn {return false}
    if lhs.binaryData != rhs.binaryData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_AsrNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsrNotification"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .notificationUnspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_AsrNotification, rhs: Data_Speech_Understanding_AsrNotification) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_ReqParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReqParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}model_name\0\u{3}config_name\0\u{3}enable_vad\0\u{3}enable_punc\0\u{3}enable_itn\0\u{3}enable_ddc\0\u{3}enable_resample\0\u{3}vad_signal\0\u{3}enable_translate\0\u{3}disable_end_punc\0\u{3}enable_speaker_info\0\u{3}enable_channel_split\0\u{3}app_lang\0\u{1}country\0\u{3}audio_type\0\u{3}enable_lid\0\u{3}reco2act_num_spk\0\u{3}reco2max_num_spk\0\u{3}enable_interrupt\0\u{3}vad_segment\0\u{3}enable_ori_text\0\u{3}enable_nonstream\0\u{4}\u{9}show_utterances\0\u{3}show_words\0\u{3}show_duration\0\u{3}show_language\0\u{3}show_volume\0\u{4}\u{2}show_speech_rate\0\u{3}show_prefetch\0\u{3}result_type\0\u{4}\u{16}start_silence_time\0\u{3}end_silence_time\0\u{3}vad_silence_time\0\u{3}min_silence_time\0\u{3}vad_mode\0\u{3}vad_segment_duration\0\u{3}end_window_size\0\u{3}force_to_speech_time\0\u{2} corpus\0\u{1}notification\0\u{3}sensitive_words_filter\0\u{4}D\u{4}show_volume_v\0")

  fileprivate class _StorageClass {
    var _modelName: String = String()
    var _configName: String = String()
    var _enableVad: Bool? = nil
    var _enablePunc: Bool? = nil
    var _enableItn: Bool? = nil
    var _enableDdc: Bool? = nil
    var _enableResample: Bool? = nil
    var _vadSignal: Bool? = nil
    var _enableTranslate: Bool? = nil
    var _disableEndPunc: Bool? = nil
    var _enableSpeakerInfo: Bool? = nil
    var _enableChannelSplit: Bool? = nil
    var _appLang: String = String()
    var _country: String = String()
    var _audioType: String = String()
    var _enableLid: Bool? = nil
    var _reco2ActNumSpk: Int32 = 0
    var _reco2MaxNumSpk: Int32 = 0
    var _enableInterrupt: Bool? = nil
    var _vadSegment: Bool? = nil
    var _enableOriText: Bool? = nil
    var _enableNonstream: Bool? = nil
    var _showUtterances: Bool? = nil
    var _showWords: Bool? = nil
    var _showDuration: Bool? = nil
    var _showLanguage: Bool? = nil
    var _showVolume: Bool? = nil
    var _showVolumeV: Bool? = nil
    var _showSpeechRate: Bool? = nil
    var _showPrefetch: Bool? = nil
    var _resultType: String = String()
    var _startSilenceTime: Int32 = 0
    var _endSilenceTime: Int32 = 0
    var _vadSilenceTime: Int32 = 0
    var _minSilenceTime: Int32 = 0
    var _vadMode: String = String()
    var _vadSegmentDuration: Int32 = 0
    var _endWindowSize: Int32 = 0
    var _forceToSpeechTime: Int32 = 0
    var _corpus: Data_Speech_Understanding_Corpus? = nil
    var _notification: Data_Speech_Understanding_AsrNotification? = nil
    var _sensitiveWordsFilter: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _modelName = source._modelName
      _configName = source._configName
      _enableVad = source._enableVad
      _enablePunc = source._enablePunc
      _enableItn = source._enableItn
      _enableDdc = source._enableDdc
      _enableResample = source._enableResample
      _vadSignal = source._vadSignal
      _enableTranslate = source._enableTranslate
      _disableEndPunc = source._disableEndPunc
      _enableSpeakerInfo = source._enableSpeakerInfo
      _enableChannelSplit = source._enableChannelSplit
      _appLang = source._appLang
      _country = source._country
      _audioType = source._audioType
      _enableLid = source._enableLid
      _reco2ActNumSpk = source._reco2ActNumSpk
      _reco2MaxNumSpk = source._reco2MaxNumSpk
      _enableInterrupt = source._enableInterrupt
      _vadSegment = source._vadSegment
      _enableOriText = source._enableOriText
      _enableNonstream = source._enableNonstream
      _showUtterances = source._showUtterances
      _showWords = source._showWords
      _showDuration = source._showDuration
      _showLanguage = source._showLanguage
      _showVolume = source._showVolume
      _showVolumeV = source._showVolumeV
      _showSpeechRate = source._showSpeechRate
      _showPrefetch = source._showPrefetch
      _resultType = source._resultType
      _startSilenceTime = source._startSilenceTime
      _endSilenceTime = source._endSilenceTime
      _vadSilenceTime = source._vadSilenceTime
      _minSilenceTime = source._minSilenceTime
      _vadMode = source._vadMode
      _vadSegmentDuration = source._vadSegmentDuration
      _endWindowSize = source._endWindowSize
      _forceToSpeechTime = source._forceToSpeechTime
      _corpus = source._corpus
      _notification = source._notification
      _sensitiveWordsFilter = source._sensitiveWordsFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._modelName) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._configName) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._enableVad) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._enablePunc) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._enableItn) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._enableDdc) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._enableResample) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._vadSignal) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._enableTranslate) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._disableEndPunc) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._enableSpeakerInfo) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._enableChannelSplit) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._appLang) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._country) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._audioType) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._enableLid) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._reco2ActNumSpk) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._reco2MaxNumSpk) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._enableInterrupt) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._vadSegment) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._enableOriText) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._enableNonstream) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._showUtterances) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._showWords) }()
        case 33: try { try decoder.decodeSingularBoolField(value: &_storage._showDuration) }()
        case 34: try { try decoder.decodeSingularBoolField(value: &_storage._showLanguage) }()
        case 35: try { try decoder.decodeSingularBoolField(value: &_storage._showVolume) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._showSpeechRate) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._showPrefetch) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._resultType) }()
        case 61: try { try decoder.decodeSingularInt32Field(value: &_storage._startSilenceTime) }()
        case 62: try { try decoder.decodeSingularInt32Field(value: &_storage._endSilenceTime) }()
        case 63: try { try decoder.decodeSingularInt32Field(value: &_storage._vadSilenceTime) }()
        case 64: try { try decoder.decodeSingularInt32Field(value: &_storage._minSilenceTime) }()
        case 65: try { try decoder.decodeSingularStringField(value: &_storage._vadMode) }()
        case 66: try { try decoder.decodeSingularInt32Field(value: &_storage._vadSegmentDuration) }()
        case 67: try { try decoder.decodeSingularInt32Field(value: &_storage._endWindowSize) }()
        case 68: try { try decoder.decodeSingularInt32Field(value: &_storage._forceToSpeechTime) }()
        case 100: try { try decoder.decodeSingularMessageField(value: &_storage._corpus) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._notification) }()
        case 102: try { try decoder.decodeSingularStringField(value: &_storage._sensitiveWordsFilter) }()
        case 362: try { try decoder.decodeSingularBoolField(value: &_storage._showVolumeV) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._modelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modelName, fieldNumber: 1)
      }
      if !_storage._configName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._configName, fieldNumber: 2)
      }
      try { if let v = _storage._enableVad {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._enablePunc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._enableItn {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._enableDdc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._enableResample {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._vadSignal {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._enableTranslate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._disableEndPunc {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._enableSpeakerInfo {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._enableChannelSplit {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      if !_storage._appLang.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appLang, fieldNumber: 13)
      }
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 14)
      }
      if !_storage._audioType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._audioType, fieldNumber: 15)
      }
      try { if let v = _storage._enableLid {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      if _storage._reco2ActNumSpk != 0 {
        try visitor.visitSingularInt32Field(value: _storage._reco2ActNumSpk, fieldNumber: 17)
      }
      if _storage._reco2MaxNumSpk != 0 {
        try visitor.visitSingularInt32Field(value: _storage._reco2MaxNumSpk, fieldNumber: 18)
      }
      try { if let v = _storage._enableInterrupt {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._vadSegment {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._enableOriText {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._enableNonstream {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._showUtterances {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._showWords {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._showDuration {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._showLanguage {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 34)
      } }()
      try { if let v = _storage._showVolume {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._showSpeechRate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 37)
      } }()
      try { if let v = _storage._showPrefetch {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 38)
      } }()
      if !_storage._resultType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resultType, fieldNumber: 39)
      }
      if _storage._startSilenceTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._startSilenceTime, fieldNumber: 61)
      }
      if _storage._endSilenceTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._endSilenceTime, fieldNumber: 62)
      }
      if _storage._vadSilenceTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vadSilenceTime, fieldNumber: 63)
      }
      if _storage._minSilenceTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minSilenceTime, fieldNumber: 64)
      }
      if !_storage._vadMode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vadMode, fieldNumber: 65)
      }
      if _storage._vadSegmentDuration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vadSegmentDuration, fieldNumber: 66)
      }
      if _storage._endWindowSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._endWindowSize, fieldNumber: 67)
      }
      if _storage._forceToSpeechTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._forceToSpeechTime, fieldNumber: 68)
      }
      try { if let v = _storage._corpus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      } }()
      try { if let v = _storage._notification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      } }()
      if !_storage._sensitiveWordsFilter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensitiveWordsFilter, fieldNumber: 102)
      }
      try { if let v = _storage._showVolumeV {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 362)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_ReqParams, rhs: Data_Speech_Understanding_ReqParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._modelName != rhs_storage._modelName {return false}
        if _storage._configName != rhs_storage._configName {return false}
        if _storage._enableVad != rhs_storage._enableVad {return false}
        if _storage._enablePunc != rhs_storage._enablePunc {return false}
        if _storage._enableItn != rhs_storage._enableItn {return false}
        if _storage._enableDdc != rhs_storage._enableDdc {return false}
        if _storage._enableResample != rhs_storage._enableResample {return false}
        if _storage._vadSignal != rhs_storage._vadSignal {return false}
        if _storage._enableTranslate != rhs_storage._enableTranslate {return false}
        if _storage._disableEndPunc != rhs_storage._disableEndPunc {return false}
        if _storage._enableSpeakerInfo != rhs_storage._enableSpeakerInfo {return false}
        if _storage._enableChannelSplit != rhs_storage._enableChannelSplit {return false}
        if _storage._appLang != rhs_storage._appLang {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._audioType != rhs_storage._audioType {return false}
        if _storage._enableLid != rhs_storage._enableLid {return false}
        if _storage._reco2ActNumSpk != rhs_storage._reco2ActNumSpk {return false}
        if _storage._reco2MaxNumSpk != rhs_storage._reco2MaxNumSpk {return false}
        if _storage._enableInterrupt != rhs_storage._enableInterrupt {return false}
        if _storage._vadSegment != rhs_storage._vadSegment {return false}
        if _storage._enableOriText != rhs_storage._enableOriText {return false}
        if _storage._enableNonstream != rhs_storage._enableNonstream {return false}
        if _storage._showUtterances != rhs_storage._showUtterances {return false}
        if _storage._showWords != rhs_storage._showWords {return false}
        if _storage._showDuration != rhs_storage._showDuration {return false}
        if _storage._showLanguage != rhs_storage._showLanguage {return false}
        if _storage._showVolume != rhs_storage._showVolume {return false}
        if _storage._showVolumeV != rhs_storage._showVolumeV {return false}
        if _storage._showSpeechRate != rhs_storage._showSpeechRate {return false}
        if _storage._showPrefetch != rhs_storage._showPrefetch {return false}
        if _storage._resultType != rhs_storage._resultType {return false}
        if _storage._startSilenceTime != rhs_storage._startSilenceTime {return false}
        if _storage._endSilenceTime != rhs_storage._endSilenceTime {return false}
        if _storage._vadSilenceTime != rhs_storage._vadSilenceTime {return false}
        if _storage._minSilenceTime != rhs_storage._minSilenceTime {return false}
        if _storage._vadMode != rhs_storage._vadMode {return false}
        if _storage._vadSegmentDuration != rhs_storage._vadSegmentDuration {return false}
        if _storage._endWindowSize != rhs_storage._endWindowSize {return false}
        if _storage._forceToSpeechTime != rhs_storage._forceToSpeechTime {return false}
        if _storage._corpus != rhs_storage._corpus {return false}
        if _storage._notification != rhs_storage._notification {return false}
        if _storage._sensitiveWordsFilter != rhs_storage._sensitiveWordsFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Understanding_Corpus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Corpus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}context\0\u{3}boosting_table_id\0\u{3}boosting_table_name\0\u{3}boosting_id\0\u{3}nnlm_id\0\u{3}correct_table_id\0\u{3}correct_table_name\0\u{3}punc_hot_words\0\u{3}hot_words_list\0\u{3}glossary_list\0\u{4}3show_match_hot_words\0\u{3}show_all_match_hot_words\0\u{3}show_effective_hot_words\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.boostingTableID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.boostingTableName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.boostingID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nnlmID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.correctTableID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.correctTableName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.puncHotWords) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.hotWordsList) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.glossaryList) }()
      case 61: try { try decoder.decodeSingularBoolField(value: &self._showMatchHotWords) }()
      case 62: try { try decoder.decodeSingularBoolField(value: &self._showAllMatchHotWords) }()
      case 63: try { try decoder.decodeSingularBoolField(value: &self._showEffectiveHotWords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.context.isEmpty {
      try visitor.visitSingularStringField(value: self.context, fieldNumber: 1)
    }
    if !self.boostingTableID.isEmpty {
      try visitor.visitSingularStringField(value: self.boostingTableID, fieldNumber: 2)
    }
    if !self.boostingTableName.isEmpty {
      try visitor.visitSingularStringField(value: self.boostingTableName, fieldNumber: 3)
    }
    if !self.boostingID.isEmpty {
      try visitor.visitSingularStringField(value: self.boostingID, fieldNumber: 4)
    }
    if !self.nnlmID.isEmpty {
      try visitor.visitSingularStringField(value: self.nnlmID, fieldNumber: 5)
    }
    if !self.correctTableID.isEmpty {
      try visitor.visitSingularStringField(value: self.correctTableID, fieldNumber: 6)
    }
    if !self.correctTableName.isEmpty {
      try visitor.visitSingularStringField(value: self.correctTableName, fieldNumber: 7)
    }
    if !self.puncHotWords.isEmpty {
      try visitor.visitSingularStringField(value: self.puncHotWords, fieldNumber: 8)
    }
    if !self.hotWordsList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hotWordsList, fieldNumber: 9)
    }
    if !self.glossaryList.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.glossaryList, fieldNumber: 10)
    }
    try { if let v = self._showMatchHotWords {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 61)
    } }()
    try { if let v = self._showAllMatchHotWords {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 62)
    } }()
    try { if let v = self._showEffectiveHotWords {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 63)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Understanding_Corpus, rhs: Data_Speech_Understanding_Corpus) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.boostingTableID != rhs.boostingTableID {return false}
    if lhs.boostingTableName != rhs.boostingTableName {return false}
    if lhs.boostingID != rhs.boostingID {return false}
    if lhs.nnlmID != rhs.nnlmID {return false}
    if lhs.correctTableID != rhs.correctTableID {return false}
    if lhs.correctTableName != rhs.correctTableName {return false}
    if lhs.puncHotWords != rhs.puncHotWords {return false}
    if lhs.hotWordsList != rhs.hotWordsList {return false}
    if lhs.glossaryList != rhs.glossaryList {return false}
    if lhs._showMatchHotWords != rhs._showMatchHotWords {return false}
    if lhs._showAllMatchHotWords != rhs._showAllMatchHotWords {return false}
    if lhs._showEffectiveHotWords != rhs._showEffectiveHotWords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
