// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common/rpcmeta.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Data_Speech_Common_RequestMeta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  /// Backend endpoint name. Gateway will also use it to infer HTTP/WebSocket URL
  /// path.
  var endpoint: String = String()

  /// Required.
  /// For historical reasons, this can be either a volcanic appid or a sail
  /// platform appKey. If both are transmitted at the same time, you need to put
  /// the volcengine appid in the AppID
  var appKey: String = String()

  /// Optional.
  /// appID in volcengine
  var appID: String = String()

  /// - Required by gateway, you must provide a ResourceID on calling gateway.
  /// - Optional for backend services, gateway doesn't need to pass this to
  /// backend.
  var resourceID: String = String()

  /// Required for Websocket connection (SDK -> Gateway), optional otherwise.
  /// In websocket communication, a connection can be reused for multiple
  /// simultaneous sessions. Servers use this ID mainly for debugging purposes.
  var connectionID: String = String()

  /// Required. Session is the minimum unit that performs a specific task. The
  /// request data in a session can be devided into a number data packets
  /// transmitted (but not necessarily processed by the server) in a sequential
  /// manner. Each data packet can be denoted by a "Sequence" number (although
  /// populating the "Sequence" field is not mandatory). In the simplest case,
  /// all request data in a session is sent as a lump (ie, only one packet).
  var sessionID: String = String()

  /// Optional, if not passed, default value 0 will be assumed. For streaming
  /// RPC, this field can be omitted (because the order of sending is preserved
  /// at the receiving side) unless the client needs the acknowledgement of
  /// packet receipt from the server side.
  var sequence: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Common_BillingItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  /// Billing unit, eg:
  /// - minute (billed by the number of minutes used)
  /// - word (billed by the number of words submitted or generated)
  /// - call (billed by the number of RPC/HTTP/Websocket calls)
  var unit: String = String()

  /// Optional.
  /// The amount that the consumer consumed counted by `BillingItem.Unit`. We use
  /// a float number because sometimes we want precision better than whole
  /// numbers.
  var quantity: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Common_Billing: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.
  /// For new billing items, use this field. This is a list because there may be
  /// more than one billing items in one request/session.
  var items: [Data_Speech_Common_BillingItem] = []

  /// Optional.
  /// For commodities that are priced w.r.t (typically audio/video) duration in
  /// milliseconds.
  var durationMsec: Int64 = 0

  /// Optional.
  /// For commodities priced w.r.t text length (number of words/tokens).
  var wordCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Data_Speech_Common_ResponseMeta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  /// The same SessionID in RequestMeta.
  var sessionID: String = String()

  /// Optional.
  /// The same sequence in RequestMeta (except that server *may* turn a positive
  /// sequence to its negative counterpart).
  var sequence: Int32 = 0

  /// Optional.
  /// Response status code.
  var statusCode: Int32 = 0

  /// Optional.
  /// Detailed status information.
  var message: String = String()

  /// Billing information in case only backend servers can collect this
  /// information.
  var billing: Data_Speech_Common_Billing {
    get {return _billing ?? Data_Speech_Common_Billing()}
    set {_billing = newValue}
  }
  /// Returns true if `billing` has been explicitly set.
  var hasBilling: Bool {return self._billing != nil}
  /// Clears the value of `billing`. Subsequent reads from it will return its default value.
  mutating func clearBilling() {self._billing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _billing: Data_Speech_Common_Billing? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "data.speech.common"

extension Data_Speech_Common_RequestMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestMeta"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{5}Endpoint\0endpoint\0\u{5}AppKey\0app_key\0\u{5}AppID\0app_id\0\u{5}ResourceID\0resource_id\0\u{5}ConnectionID\0connection_id\0\u{5}SessionID\0session_id\0\u{5}Sequence\0sequence\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.connectionID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.sequence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.appKey.isEmpty {
      try visitor.visitSingularStringField(value: self.appKey, fieldNumber: 2)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 3)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 4)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 5)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 6)
    }
    if self.sequence != 0 {
      try visitor.visitSingularInt32Field(value: self.sequence, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Common_RequestMeta, rhs: Data_Speech_Common_RequestMeta) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.appKey != rhs.appKey {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Common_BillingItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BillingItem"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{5}Unit\0unit\0\u{5}Quantity\0quantity\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.quantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 1)
    }
    if self.quantity.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Common_BillingItem, rhs: Data_Speech_Common_BillingItem) -> Bool {
    if lhs.unit != rhs.unit {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Common_Billing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Billing"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{5}Items\0items\0\u{5}DurationMsec\0duration_msec\0\u{5}WordCount\0word_count\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.durationMsec) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.wordCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    if self.durationMsec != 0 {
      try visitor.visitSingularInt64Field(value: self.durationMsec, fieldNumber: 2)
    }
    if self.wordCount != 0 {
      try visitor.visitSingularInt64Field(value: self.wordCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Common_Billing, rhs: Data_Speech_Common_Billing) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.durationMsec != rhs.durationMsec {return false}
    if lhs.wordCount != rhs.wordCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Data_Speech_Common_ResponseMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseMeta"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{5}SessionID\0session_id\0\u{5}Sequence\0sequence\0\u{5}StatusCode\0status_code\0\u{5}Message\0message\0\u{5}Billing\0billing\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.sequence) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.statusCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._billing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if self.sequence != 0 {
      try visitor.visitSingularInt32Field(value: self.sequence, fieldNumber: 2)
    }
    if self.statusCode != 0 {
      try visitor.visitSingularInt32Field(value: self.statusCode, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    try { if let v = self._billing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Data_Speech_Common_ResponseMeta, rhs: Data_Speech_Common_ResponseMeta) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs._billing != rhs._billing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
